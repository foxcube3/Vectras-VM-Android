plugins {
    id 'com.android.application'
}

android {
    namespace = 'com.vectras.vm'
    compileSdk = rootProject.ext.compileApi

    defaultConfig {
        applicationId = "com.vectras.vm"
        minSdk = rootProject.ext.minApi
        targetSdk = rootProject.ext.targetApi
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled = false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    buildFeatures {
        viewBinding true
        dataBinding true
    }
    lint {
        // Create a baseline for the existing lint warnings/errors so the build is not blocked.
        // Run `./gradlew updateLintBaseline` once to generate `lint-baseline.xml` and commit it.
        // This preserves current issues while allowing incremental fixes over time.
        baseline = file("lint-baseline.xml")
        abortOnError false
    }
}

dependencies {
    // Using version catalog aliases (see gradle/libs.versions.toml)
    implementation libs.glide
    annotationProcessor libs.glide.compiler
    testImplementation libs.junit
    androidTestImplementation libs.ext.junit
    androidTestImplementation libs.espresso
    implementation libs.androidx.appcompat
    implementation libs.androidx.core.ktx
    implementation libs.material
    implementation libs.preference
    implementation libs.constraintlayout
    implementation libs.lottie
    implementation project(':terminal-view')
    implementation libs.gson
    implementation libs.retrofit
    implementation libs.retrofit.gson
    implementation libs.guava
    implementation libs.ztzip
    implementation libs.swiperefreshlayout
    implementation libs.activity.ktx
    implementation libs.recyclerview
}

// --- Firmware / ROM asset fetch (non-LFS on fork) ------------------------------------------
// Provides a lightweight way to obtain large firmware files (e.g., QEMU_VARS.img)
// without committing them to this fork. Precedence for URL selection:
//   -PfirmwareUrl Gradle property > QEMU_VARS_URL env var > placeholder default.
// Optional integrity check:
//   -PfirmwareSha256 or QEMU_VARS_SHA256 env var (expected lowercase hex). If provided, the
// downloaded file's SHA-256 must match or the build fails.
// Retry behavior controlled by -PfirmwareAttempts (default 3) or env QEMU_VARS_ATTEMPTS.
// Skip fetch: -PskipFirmware ; Skip verification: -PskipFirmwareVerify
// NOTE: If both skipFirmware and verify requested, verify is effectively skipped (no file).

def firmwareDir = file("${project.projectDir}/src/main/assets/roms")
// Firmware variant (e.g., default, debug, secure). Allows multiple images hosted externally.
def firmwareVariant = (project.findProperty('firmwareVariant') ?: System.getenv('QEMU_VARS_VARIANT') ?: 'default')
// Define multiple assets: name -> extension
def firmwareAssets = [
    [base: 'QEMU_VARS', ext: 'img', envUrl: 'QEMU_VARS_URL', envSha: 'QEMU_VARS_SHA256'],
    [base: 'RELEASEX64_OVMF_VARS', ext: 'fd', envUrl: 'RELEASEX64_OVMF_VARS_URL', envSha: 'RELEASEX64_OVMF_VARS_SHA256']
]
def primaryAsset = firmwareAssets[0]
def firmwareBaseName = primaryAsset.base
def firmwareFiles = firmwareAssets.collect { a -> file("${firmwareDir}/${a.base}-${firmwareVariant}.${a.ext}") }
// Primary file used by existing single-file tasks for backward compatibility
def firmwareFile = firmwareFiles[0]

def firmwareUrl = (project.findProperty('firmwareUrl') ?: System.getenv(primaryAsset.envUrl) ?: "https://example.com/path/to/${primaryAsset.base}-${firmwareVariant}.${primaryAsset.ext}")
def expectedSha256 = (project.findProperty('firmwareSha256') ?: System.getenv(primaryAsset.envSha))
def sampleShaPlaceholder = '3d4c2c9f1a9e5b4b2f6a2e7c0f1d3b4c5a6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a'
if (expectedSha256 && expectedSha256.equalsIgnoreCase(sampleShaPlaceholder) && !project.hasProperty('allowSampleFirmwareSha')) {
    logger.warn("WARNING: Using sample placeholder firmware SHA-256. Replace with production value or pass -PallowSampleFirmwareSha to suppress this warning.")
}
def maxAttempts = (project.findProperty('firmwareAttempts') ?: System.getenv('QEMU_VARS_ATTEMPTS') ?: '3') as int
def skipFirmware = project.hasProperty('skipFirmware')
def skipFirmwareVerify = project.hasProperty('skipFirmwareVerify')

def computeSha256 = { File f ->
    if (!f.exists()) return null
    def md = java.security.MessageDigest.getInstance('SHA-256')
    f.withInputStream { is ->
        byte[] buf = new byte[8192]
        int r
        while ((r = is.read(buf)) != -1) {
            md.update(buf, 0, r)
        }
    }
    return md.digest().collect { String.format('%02x', it) }.join('')
}

// Cache metadata (e.g., ETag) to allow conditional HTTP requests.
def metadataFiles = firmwareAssets.collect { a -> file("${firmwareDir}/${a.base}-${firmwareVariant}.meta") }
def metadataFile = metadataFiles[0]
def readMetaFile = { File meta, String key ->
    if (!meta.exists()) return null
    def props = new Properties()
    meta.withInputStream { props.load(it) }
    return props.getProperty(key)
}
def writeMetaFile = { File meta, Map<String,String> map ->
    def props = new Properties()
    if (meta.exists()) { meta.withInputStream { props.load(it) } } else { if (!firmwareDir.exists()) firmwareDir.mkdirs() }
    map.each { k,v -> if (v!=null) props.setProperty(k,v) }
    meta.withOutputStream { out -> props.store(out, 'Firmware metadata cache') }
}

tasks.register('fetchFirmware') {
    description = 'Downloads firmware image if missing or outdated (retries, SHA-256 verify, ETag cache).'
    group = 'vectras'
    outputs.file(firmwareFile)
    onlyIf { !skipFirmware }
    doLast {
    boolean needsDownload = !firmwareFile.exists()
    String cachedEtag = readMetaFile(metadataFile, 'etag')
        if (!needsDownload) {
            logger.lifecycle("Firmware present: ${firmwareFile.name} (${firmwareFile.length()} bytes)")
            // Optionally attempt conditional HEAD to verify if remote changed when hash provided
            // (skip if no hash + no variant change)
        }
        if (!firmwareDir.exists() && !firmwareDir.mkdirs()) {
            throw new GradleException("Could not create firmware directory: ${firmwareDir}")
        }
        if (!needsDownload) {
            logger.lifecycle("No download needed (file exists). Use -PforceFirmware or delete file to refetch.")
        }
        if (project.hasProperty('forceFirmware')) {
            logger.lifecycle('forceFirmware flag set: re-downloading regardless of existing file.')
            needsDownload = true
        }
        if (!needsDownload) {
            // Still perform integrity verification if expected hash provided
            if (expectedSha256) {
                def actualPre = computeSha256(firmwareFile)
                if (!actualPre?.equalsIgnoreCase(expectedSha256)) {
                    logger.lifecycle("Existing firmware hash mismatch; re-downloading.")
                    needsDownload = true
                }
            }
        }
        if (!needsDownload) return
        logger.lifecycle("Fetching firmware variant='${firmwareVariant}' from ${firmwareUrl} (maxAttempts=${maxAttempts})")
        int attempt = 1
        boolean success = false
        while (attempt <= maxAttempts && !success) {
            File tmp = new File(firmwareFile.parentFile, firmwareFile.name + '.part')
            if (tmp.exists()) tmp.delete()
            try {
                def url = new URL(firmwareUrl)
                url.openConnection().with { conn ->
                    conn.connectTimeout = 15000
                    conn.readTimeout = 600000 // 10 min
                    if (cachedEtag) {
                        conn.setRequestProperty('If-None-Match', cachedEtag)
                    }
                    int code = conn.getResponseCode()
                    if (code == 304) {
                        logger.lifecycle("[attempt ${attempt}] Remote reports Not Modified (ETag match); skipping download body.")
                        return
                    }
                    conn.inputStream.withCloseable { input ->
                        tmp.withOutputStream { out ->
                            byte[] buf = new byte[1 * 1024 * 1024]
                            long total = 0
                            long lastReport = System.currentTimeMillis()
                            int r
                            while ((r = input.read(buf)) != -1) {
                                out.write(buf, 0, r)
                                total += r
                                def now = System.currentTimeMillis()
                                if (now - lastReport > 5000) {
                                    logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Downloaded %,d bytes...", attempt, total))
                                    lastReport = now
                                }
                            }
                            logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Download complete (%,d bytes).", attempt, total))
                        }
                    }
                    def etag = conn.getHeaderField('ETag')
                    if (etag) {
                        writeMetaFile(metadataFile, [etag: etag])
                        logger.lifecycle("Captured ETag (primary asset): ${etag}")
                    }
                }
                // Atomic move
                if (firmwareFile.exists()) firmwareFile.delete()
                if (!tmp.renameTo(firmwareFile)) {
                    throw new GradleException("Could not rename temp file ${tmp} to ${firmwareFile}")
                }
                success = true
            } catch (Throwable t) {
                logger.warn("[attempt ${attempt}] Firmware download failed: ${t.class.simpleName}: ${t.message}")
                attempt++
                if (attempt <= maxAttempts) {
                    long backoff = (long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L) // 1s,2s,4s,8s...
                    logger.lifecycle("Retrying in ${backoff} ms ...")
                    sleep(backoff)
                }
            }
        }
        if (!success) {
            throw new GradleException("Failed to download firmware after ${maxAttempts} attempts: ${firmwareUrl}")
        }
        if (expectedSha256) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                firmwareFile.delete()
                throw new GradleException("Firmware SHA-256 mismatch. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware SHA-256 verified: ${actual}")
        } else {
            logger.lifecycle("No expected SHA-256 provided; skipping integrity verification.")
        }
    }
}

// --- Optional GPG signature verification (detached .sig) -----------------------------
// Provide -PfirmwareSigUrl or env QEMU_VARS_SIG_URL for primary asset. Requires gpg in PATH.
def firmwareSigUrl = (project.findProperty('firmwareSigUrl') ?: System.getenv('QEMU_VARS_SIG_URL'))
def firmwareSigFile = file("${firmwareFile}.sig")

tasks.register('fetchFirmwareSignature') {
    description = 'Fetches detached GPG signature for primary firmware if firmwareSigUrl provided.'
    group = 'vectras'
    onlyIf { firmwareSigUrl && !skipFirmware }
    doLast {
        logger.lifecycle("Downloading signature from ${firmwareSigUrl}")
        def url = new URL(firmwareSigUrl)
        url.openConnection().with { c ->
            c.connectTimeout = 10000
            c.readTimeout = 60000
            c.inputStream.withCloseable { input ->
                firmwareSigFile.withOutputStream { out -> out << input }
            }
        }
        logger.lifecycle("Signature saved: ${firmwareSigFile} (${firmwareSigFile.length()} bytes)")
    }
}

tasks.register('verifyFirmwareSignature') {
    description = 'Verifies firmware GPG signature (requires gpg and fetched signature).'
    group = 'verification'
    dependsOn 'fetchFirmware', 'fetchFirmwareSignature'
    onlyIf { firmwareSigUrl && !skipFirmware }
    doLast {
        if (!firmwareSigFile.exists()) throw new GradleException("Signature file missing: ${firmwareSigFile}")
        logger.lifecycle("Verifying signature via gpg --verify ...")
        def proc = [ 'gpg', '--verify', firmwareSigFile.absolutePath, firmwareFile.absolutePath ].execute()
        def out = new StringBuffer(); def err = new StringBuffer();
        proc.consumeProcessOutput(out, err)
        proc.waitFor()
        logger.lifecycle(out.toString())
        if (proc.exitValue() != 0) {
            logger.error(err.toString())
            throw new GradleException("Firmware signature verification failed (exit=${proc.exitValue()})")
        }
        logger.lifecycle("Firmware signature verified successfully.")
    }
}

tasks.register('ciAllFirmwareSecureCheck') {
    description = 'CI: fetch all assets + verify primary hash + signature if provided + print hash.'
    group = 'verification'
    dependsOn 'fetchAllFirmware', 'verifyFirmware', 'printFirmwareSha256', 'verifyFirmwareSignature'
}

tasks.register('verifyFirmware') {
    description = 'Verifies existing firmware file matches expected SHA-256 (if provided).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (skipFirmware) {
            logger.lifecycle('Firmware fetch skipped; verifyFirmware doing nothing.')
            return
        }
        if (!firmwareFile.exists()) {
            throw new GradleException("Firmware file not found: ${firmwareFile}")
        }
        if (expectedSha256 && !skipFirmwareVerify) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                throw new GradleException("Firmware verification failed. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware verification succeeded (SHA-256=${actual}).")
        } else {
            logger.lifecycle("No firmware SHA-256 provided or verification skipped.")
        }
    }
}

// Print computed SHA-256 (after fetch or existing) for convenience
tasks.register('printFirmwareSha256') {
    description = 'Prints SHA-256 of firmware file (fetches first if needed unless skipped).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (!firmwareFile.exists()) {
            logger.lifecycle("Firmware not present; nothing to hash.")
            return
        }
        def actual = computeSha256(firmwareFile)
        logger.lifecycle("Firmware file: ${firmwareFile.name}")
        logger.lifecycle("Variant: ${firmwareVariant}")
        logger.lifecycle("SHA-256: ${actual}")
        println(actual)
    }
}

// Multi-asset parallel fetch (best-effort). Each asset can override URL & hash via properties:
// -Passet.<base>.url / env <BASE>_URL   and -Passet.<base>.sha256 / env <BASE>_SHA256
// Example: -Passet.RELEASEX64_OVMF_VARS.url=https://.../RELEASEX64_OVMF_VARS-default.fd
tasks.register('fetchAllFirmware') {
    group = 'vectras'
    description = 'Fetches all defined firmware assets (primary + secondary).'    
    onlyIf { !skipFirmware }
    doLast {
        if (!firmwareDir.exists()) firmwareDir.mkdirs()
        firmwareAssets.parallelStream().forEach { a ->
            File target = file("${firmwareDir}/${a.base}-${firmwareVariant}.${a.ext}")
            File meta = file("${firmwareDir}/${a.base}-${firmwareVariant}.meta")
            String urlOverride = (project.findProperty("asset.${a.base}.url") ?: System.getenv(a.envUrl) ?: "https://example.com/path/to/${a.base}-${firmwareVariant}.${a.ext}")
            String shaOverride = (project.findProperty("asset.${a.base}.sha256") ?: System.getenv(a.envSha))
            boolean force = project.hasProperty('forceFirmware')
            boolean need = force || !target.exists()
            if (!need && shaOverride) {
                def existing = computeSha256(target)
                if (!existing?.equalsIgnoreCase(shaOverride)) {
                    need = true
                }
            }
            if (!need) {
                logger.lifecycle("[multi] ${target.name} already present")
                return
            }
            logger.lifecycle("[multi] Downloading ${a.base} variant=${firmwareVariant} from ${urlOverride}")
            File tmp = new File(target.parentFile, target.name + '.part')
            if (tmp.exists()) tmp.delete()
            int attempt = 1
            int max = maxAttempts
            boolean ok = false
            while (attempt <= max && !ok) {
                try {
                    def u = new URL(urlOverride)
                    u.openConnection().with { conn ->
                        conn.connectTimeout = 15000
                        conn.readTimeout = 600000
                        conn.inputStream.withCloseable { input ->
                            tmp.withOutputStream { out ->
                                byte[] buf = new byte[1*1024*1024]
                                int r
                                long total = 0
                                long lastReport = System.currentTimeMillis()
                                while ((r = input.read(buf)) != -1) {
                                    out.write(buf,0,r)
                                    total += r
                                    if (System.currentTimeMillis() - lastReport > 5000) {
                                        logger.lifecycle(String.format(Locale.ROOT, "[multi %s attempt %d] %,d bytes", a.base, attempt, total))
                                        lastReport = System.currentTimeMillis()
                                    }
                                }
                                logger.lifecycle(String.format(Locale.ROOT, "[multi %s attempt %d] complete (%,d bytes)", a.base, attempt, total))
                            }
                        }
                        def et = conn.getHeaderField('ETag')
                        if (et) writeMetaFile(meta, [etag: et])
                    }
                    if (target.exists()) target.delete()
                    if (!tmp.renameTo(target)) throw new GradleException("Could not finalize ${target}")
                    if (shaOverride) {
                        def got = computeSha256(target)
                        if (!got?.equalsIgnoreCase(shaOverride)) {
                            target.delete(); throw new GradleException("SHA mismatch for ${a.base} expected=${shaOverride} got=${got}")
                        }
                    }
                    ok = true
                } catch (Throwable t) {
                    logger.warn("[multi ${a.base}] attempt ${attempt} failed: ${t.class.simpleName}: ${t.message}")
                    attempt++
                    if (attempt <= max) {
                        long back = (long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L)
                        sleep(back)
                    }
                }
            }
            if (!ok) throw new GradleException("Failed to fetch asset ${a.base} after ${max} attempts")
            if (!shaOverride) logger.lifecycle("[multi] ${a.base} done (no hash to verify)")
        }
    }
}

// Aggregate multi asset + standard verify (primary) for CI convenience
tasks.register('ciAllFirmwareCheck') {
    group = 'verification'
    description = 'Fetch all assets + verify primary asset hash + print primary hash.'
    dependsOn 'fetchAllFirmware', 'verifyFirmware', 'printFirmwareSha256'
}

// Aggregate CI convenience task: fetch + verify (if hash) + print hash
tasks.register('ciFirmwareCheck') {
    description = 'CI helper: ensures firmware present, verifies (if hash), and prints hash.'
    group = 'verification'
    dependsOn tasks.named('verifyFirmware'), tasks.named('printFirmwareSha256')
}

// Ensure firmware is present before building APK (unless skipped)
tasks.matching { it.name == 'preBuild' }.configureEach {
    if (!skipFirmware) {
        dependsOn tasks.named('fetchFirmware')
    } else {
        logger.lifecycle('Skipping firmware fetch due to -PskipFirmware flag.')
    }
}

// Apply Crashlytics plugin if the classpath provides it
try {
    apply plugin: 'com.google.firebase.crashlytics'
} catch (Exception ignored) {
    logger.warn('Firebase Crashlytics Gradle plugin not available on classpath; skipping crashlytics setup.')
}

// Apply Google Services plugin only if google-services.json exists.
if (file("google-services.json").exists()) {
    apply plugin: 'com.google.gms.google-services'
} else {
    logger.warn('google-services.json not found in app/ — skipping com.google.gms.google-services plugin. Add the file from Firebase Console to enable Analytics and other Firebase services.')
}
