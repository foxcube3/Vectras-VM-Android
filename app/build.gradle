plugins {
    alias(libs.plugins.android.application)
}

// Hybrid firmware acquisition support (archive flow default). We add this import early so
// JsonSlurper is available to tasks defined later in the script.

android {
    namespace = 'com.vectras.vm'
    compileSdk = rootProject.ext.compileApi

    defaultConfig {
        applicationId = "com.vectras.vm"
        minSdk = rootProject.ext.minApi
        targetSdk = rootProject.ext.targetApi
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled = false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    buildFeatures {
        viewBinding true
        dataBinding true
    }
    // ABI splits: default only arm64-v8a (native lib present). Enable all with -PallAbis
    splits {
        abi {
            enable true
            reset()
            if (project.hasProperty('allAbis')) {
                include 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'
                universalApk true
            } else {
                include 'arm64-v8a'
                universalApk false
            }
        }
    }
    packagingOptions {
        jniLibs {
            useLegacyPackaging false
        }
    }
    // (Optional) specify ndkVersion for deterministic native builds; left unset to use default.
    lint {
        // Create a baseline for the existing lint warnings/errors so the build is not blocked.
        // Run `./gradlew updateLintBaseline` once to generate `lint-baseline.xml` and commit it.
        // This preserves current issues while allowing incremental fixes over time.
        baseline = file("lint-baseline.xml")
        abortOnError false
    }
}

dependencies {
    // Using version catalog aliases (see gradle/libs.versions.toml)
    implementation libs.glide
    annotationProcessor libs.glide.compiler
    testImplementation libs.junit
    androidTestImplementation libs.ext.junit
    androidTestImplementation libs.espresso
    implementation libs.androidx.appcompat
    implementation libs.androidx.core.ktx
    implementation libs.material
    implementation libs.preference
    implementation libs.constraintlayout
    implementation libs.lottie
    implementation project(':terminal-view')
    implementation libs.gson
    implementation libs.retrofit
    implementation libs.retrofit.gson
    implementation libs.guava
    implementation libs.ztzip
    implementation libs.swiperefreshlayout
    implementation libs.activity.ktx
    implementation libs.recyclerview
    // (Legacy explicit versions block from master removed in favor of version catalog above)
}

// --- Firmware / ROM asset fetch (non-LFS on fork) ------------------------------------------
// Provides a lightweight way to obtain large firmware files (e.g., QEMU_VARS.img)
// without committing them to this fork. Precedence for URL selection:
//   -PfirmwareUrl Gradle property > QEMU_VARS_URL env var > placeholder default.
// Optional integrity check:
//   -PfirmwareSha256 or QEMU_VARS_SHA256 env var (expected lowercase hex). If provided, the
// downloaded file's SHA-256 must match or the build fails.
// Retry behavior controlled by -PfirmwareAttempts (default 3) or env QEMU_VARS_ATTEMPTS.
// Skip fetch: -PskipFirmware ; Skip verification: -PskipFirmwareVerify
// NOTE: If both skipFirmware and verify requested, verify is effectively skipped (no file).

def firmwareDir = file("${project.projectDir}/src/main/assets/roms")
// Firmware variant (e.g., default, debug, secure). Allows multiple images hosted externally.
def firmwareVariant = (project.findProperty('firmwareVariant') ?: System.getenv('QEMU_VARS_VARIANT') ?: 'default')
// Define multiple assets: name -> extension
def firmwareAssets = [
    [base: 'QEMU_VARS', ext: 'img', envUrl: 'QEMU_VARS_URL', envSha: 'QEMU_VARS_SHA256'],
    [base: 'RELEASEX64_OVMF_VARS', ext: 'fd', envUrl: 'RELEASEX64_OVMF_VARS_URL', envSha: 'RELEASEX64_OVMF_VARS_SHA256']
]
def primaryAsset = firmwareAssets[0]
def firmwareBaseName = primaryAsset.base
def firmwareFiles = firmwareAssets.collect { a -> file("${firmwareDir}/${a.base}-${firmwareVariant}.${a.ext}") }
// Primary file used by existing single-file tasks for backward compatibility
def firmwareFile = firmwareFiles[0]

def firmwareUrl = (project.findProperty('firmwareUrl') ?: System.getenv(primaryAsset.envUrl) ?: "https://example.com/path/to/${primaryAsset.base}-${firmwareVariant}.${primaryAsset.ext}")
def expectedSha256 = (project.findProperty('firmwareSha256') ?: System.getenv(primaryAsset.envSha))
def sampleShaPlaceholder = '3d4c2c9f1a9e5b4b2f6a2e7c0f1d3b4c5a6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a'
if (expectedSha256 && expectedSha256.equalsIgnoreCase(sampleShaPlaceholder) && !project.hasProperty('allowSampleFirmwareSha')) {
    logger.warn("WARNING: Using sample placeholder firmware SHA-256. Replace with production value or pass -PallowSampleFirmwareSha to suppress this warning.")
}
def maxAttempts = (project.findProperty('firmwareAttempts') ?: System.getenv('QEMU_VARS_ATTEMPTS') ?: '3') as int
def skipFirmware = project.hasProperty('skipFirmware')
def skipFirmwareVerify = project.hasProperty('skipFirmwareVerify')

def computeSha256 = { File f ->
    if (!f.exists()) return null
    def md = java.security.MessageDigest.getInstance('SHA-256')
    f.withInputStream { is ->
        byte[] buf = new byte[8192]
        int r
        while ((r = is.read(buf)) != -1) {
            md.update(buf, 0, r)
        }
    }
    return md.digest().collect { String.format('%02x', it) }.join('')
}

// ---------------- Hybrid Archive Flow (default) -------------------------------------------
// Many upstream builds package firmware inside an architecture-specific setup archive.
// We support extracting only the needed firmware blobs instead of per-file HTTP downloads.
// Conditions enabling archive flow:
//  - No explicit per-file override (no -PfirmwareUrl and no env for primary asset)
//  - Not disabled via -PdisableSetupArchiveFlow
// In archive mode, we:
//  1. Obtain setupfiles.json (local copy or remote URL override)
//  2. Resolve the per-arch archive URL
//  3. Download the tar.gz
//  4. Extract a subset of firmware files into the firmwareDir
//  5. Short-circuit direct download tasks (they just validate presence)

def perFileOverrideProvided = (project.hasProperty('firmwareUrl') || System.getenv(primaryAsset.envUrl))
def archiveEnabled = !project.hasProperty('disableSetupArchiveFlow') && !perFileOverrideProvided
def setupWorkDir = file("${buildDir}/firmwareSetup")
def setupManifestFile = file("${setupWorkDir}/setupfiles.json")
def resolvedArchiveUrlFile = file("${setupWorkDir}/resolved.url")
def setupArchiveFile = file("${setupWorkDir}/setup.tar.gz")
def setupFilesUrlProp = (project.findProperty('setupFilesUrl') ?: System.getenv('SETUPFILES_URL'))
// Default arch detection: property > explicit override > arm64 fallback.
def setupArch = (project.findProperty('setupArch') ?: System.getenv('SETUP_ARCH') ?: 'arm64')

tasks.register('fetchSetupManifest') {
    group = 'vectras'
    description = 'Obtains setupfiles.json manifest (local copy or remote override).'
    onlyIf { archiveEnabled }
    outputs.file(setupManifestFile)
    doLast {
        if (!setupWorkDir.exists()) setupWorkDir.mkdirs()
        if (setupFilesUrlProp) {
            logger.lifecycle("[archive] Downloading setup manifest from ${setupFilesUrlProp}")
            new URL(setupFilesUrlProp).withInputStream { ins -> setupManifestFile.bytes = ins.bytes }
        } else {
            // Use repo-local copy to avoid network when possible
            def local = file("${rootProject.projectDir}/web/data/setupfiles.json")
            if (!local.exists()) throw new GradleException("Local setupfiles.json not found at ${local}")
            logger.lifecycle("[archive] Using local setup manifest ${local}")
            setupManifestFile.text = local.text
        }
        logger.lifecycle("[archive] setupfiles.json saved (${setupManifestFile.length()} bytes)")
    }
}

tasks.register('resolveSetupArchive') {
    group = 'vectras'
    description = 'Parses setupfiles.json to find archive URL for the selected architecture.'
    onlyIf { archiveEnabled }
    dependsOn 'fetchSetupManifest'
    outputs.file(resolvedArchiveUrlFile)
    doLast {
        // Lightweight manual parse (manifest is simple key:value JSON object).
        def map = [:]
        setupManifestFile.eachLine { line ->
            def m = line =~ /"([^\"]+)"\s*:\s*"([^\"]+)"/
            if (m.find()) {
                map[m.group(1)] = m.group(2)
            }
        }
        if (map.isEmpty()) throw new GradleException('[archive] Failed to parse setup manifest (no key:value pairs found).')
        def keyCandidates = [setupArch, setupArch.toLowerCase(), setupArch.toUpperCase()]
        def chosen = keyCandidates.collect { k -> map[k] }.find { it != null }
        if (chosen == null) {
            throw new GradleException("[archive] No entry in setup manifest for arch='${setupArch}'. Available keys=${map.keySet()}")
        }
        resolvedArchiveUrlFile.text = chosen.trim()
        logger.lifecycle("[archive] Resolved setup archive URL: ${chosen}")
    }
}

tasks.register('downloadSetupArchive') {
    group = 'vectras'
    description = 'Downloads architecture-specific setup archive (tar.gz) referenced by manifest.'
    onlyIf { archiveEnabled }
    dependsOn 'resolveSetupArchive'
    outputs.file(setupArchiveFile)
    doLast {
        if (!setupWorkDir.exists()) setupWorkDir.mkdirs()
        String url = resolvedArchiveUrlFile.text.trim()
        logger.lifecycle("[archive] Fetching setup archive from ${url}")
        File tmp = new File(setupArchiveFile.parentFile, setupArchiveFile.name + '.part')
        if (tmp.exists()) tmp.delete()
        int attempt = 1; int max = 3; boolean ok = false
        while (attempt <= max && !ok) {
            try {
                new URL(url).openConnection().with { conn ->
                    conn.connectTimeout = 20000; conn.readTimeout = 900000
                    conn.inputStream.withCloseable { ins -> tmp.withOutputStream { out -> out << ins } }
                }
                if (setupArchiveFile.exists()) setupArchiveFile.delete()
                if (!tmp.renameTo(setupArchiveFile)) throw new GradleException("[archive] Could not finalize archive file")
                ok = true
            } catch (Throwable t) {
                logger.warn("[archive] attempt ${attempt} failed: ${t.class.simpleName}: ${t.message}")
                attempt++
                if (attempt <= max) {
                    sleep((long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L))
                }
            }
        }
        if (!ok) throw new GradleException("[archive] Failed to download setup archive after ${max} attempts")
        logger.lifecycle("[archive] Archive downloaded (${setupArchiveFile.length()} bytes)")
    }
}

tasks.register('extractFirmwareFromArchive') {
    group = 'vectras'
    description = 'Extracts firmware files from setup archive into firmwareDir.'
    onlyIf { archiveEnabled }
    dependsOn 'downloadSetupArchive'
    // We declare the primary firmware file as an output indicator; others are implicit.
    outputs.dir(firmwareDir)
    doLast {
        def setupArchiveShaFile = file("${setupWorkDir}/setup.tar.gz.sha256")
        if (!setupArchiveFile.exists()) throw new GradleException('[archive] Archive missing before extraction.')
        if (!firmwareDir.exists()) firmwareDir.mkdirs()
        // Extract only relevant firmware patterns (tunable list).
        def patterns = [
            'QEMU_VARS*.img', 'QEMU_EFI*.img',
            'RELEASEX64_OVMF*.fd', 'bios-*.bin', 'bios*.bin'
        ]
        logger.lifecycle("[archive] Extracting firmware patterns: ${patterns}")
        // Use a temporary expand dir then selective copy (ensures patterns work across subdirs)
        def tree = project.tarTree(resources.gzip(setupArchiveFile))
        def extracted = [] as Set
        tree.visit { f ->
            if (!f.isDirectory()) {
                def name = f.name
                boolean match = patterns.any { pat ->
                    def regex = pat.replace('.', '\\.').replace('*', '.*')
                    return name ==~ /${regex}/
                }
                if (match) {
                    // Copy stream contents into target file under firmwareDir
                    def target = new File(firmwareDir, name)
                    target.withOutputStream { out -> out << f.open() }
                    extracted << name
                }
            }
        }
        if (extracted.isEmpty()) {
            logger.warn('[archive] No firmware files matched extraction patterns – check archive contents or patterns.')
        } else {
            logger.lifecycle("[archive] Extracted firmware files: ${extracted.join(', ')}")
        }
        // Initial inventory (will be enriched later with primarySource)
        def invList = extracted.collect { n ->
            def f = new File(firmwareDir, n)
            [ name: n, size: f.length(), sha256: computeSha256(f), source: 'archive' ]
        }
        def invFile = new File(firmwareDir, 'firmware-inventory.json')
        invFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson([
            archiveUrl: (resolvedArchiveUrlFile.exists() ? resolvedArchiveUrlFile.text.trim() : null),
            archiveSha256: (setupArchiveShaFile.exists() ? setupArchiveShaFile.text.trim() : null),
            architecture: setupArch,
            primarySource: null,
            generatedAtUtc: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC')),
            files: invList
        ]))
        logger.lifecycle("[archive] Inventory initialized: ${invFile}")
    }
}

// Cache metadata (e.g., ETag) to allow conditional HTTP requests.
def metadataFiles = firmwareAssets.collect { a -> file("${firmwareDir}/${a.base}-${firmwareVariant}.meta") }
def metadataFile = metadataFiles[0]
def readMetaFile = { File meta, String key ->
    if (!meta.exists()) return null
    def props = new Properties()
    meta.withInputStream { props.load(it) }
    return props.getProperty(key)
}
def writeMetaFile = { File meta, Map<String,String> map ->
    def props = new Properties()
    if (meta.exists()) { meta.withInputStream { props.load(it) } } else { if (!firmwareDir.exists()) firmwareDir.mkdirs() }
    map.each { k,v -> if (v!=null) props.setProperty(k,v) }
    meta.withOutputStream { out -> props.store(out, 'Firmware metadata cache') }
}

tasks.register('fetchFirmware') {
    description = 'Downloads firmware image if missing or outdated (retries, SHA-256 verify, ETag cache).'
    group = 'vectras'
    outputs.file(firmwareFile)
    onlyIf { !skipFirmware }
    // In archive mode we ensure extraction before checking presence
    if (archiveEnabled) {
        dependsOn 'extractFirmwareFromArchive'
    }
    doLast {
    if (archiveEnabled) {
        String primarySource = 'archive'
        def baseNoVariantFile = new File(firmwareDir, "${firmwareBaseName}.img")
        def upstreamBaseUrl = (project.findProperty('rawFirmwareBaseUrl') ?: System.getenv('RAW_FIRMWARE_BASE_URL') ?: 'https://raw.githubusercontent.com/xoureldeen/Vectras-VM-Android/master/app/src/main/assets/roms')
        if (!firmwareFile.exists()) {
            if (firmwareVariant == 'default' && !baseNoVariantFile.exists()) {
                def rawUrl = upstreamBaseUrl.endsWith('/') ? upstreamBaseUrl + "${firmwareBaseName}.img" : upstreamBaseUrl + '/' + "${firmwareBaseName}.img"
                logger.lifecycle("[archive] Primary asset missing; attempting upstream raw fetch: ${rawUrl}")
                try {
                    new URL(rawUrl).openConnection().with { c ->
                        c.connectTimeout = 15000; c.readTimeout = 120000
                        c.inputStream.withCloseable { ins -> baseNoVariantFile.withOutputStream { out -> out << ins } }
                    }
                    if (baseNoVariantFile.exists() && baseNoVariantFile.length() > 0) {
                        primarySource = 'upstreamRaw'
                        logger.lifecycle("[archive] Retrieved upstream raw firmware (${baseNoVariantFile.length()} bytes)")
                        // Upstream SHA check early (expected hash may target this canonical file)
                        if (expectedSha256) {
                            def upstreamSha = computeSha256(baseNoVariantFile)
                            if (!upstreamSha?.equalsIgnoreCase(expectedSha256)) {
                                baseNoVariantFile.delete()
                                throw new GradleException("[archive] Upstream raw firmware hash mismatch. Expected=${expectedSha256} Actual=${upstreamSha}")
                            }
                            logger.lifecycle("[archive] Upstream raw firmware SHA-256 verified (${upstreamSha})")
                        }
                    }
                } catch (Throwable t) {
                    logger.warn("[archive] Upstream raw fetch failed: ${t.class.simpleName}: ${t.message}")
                }
            }
            if (!firmwareFile.exists() && baseNoVariantFile.exists()) {
                try {
                    java.nio.file.Files.copy(baseNoVariantFile.toPath(), firmwareFile.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING)
                    logger.lifecycle("[archive] Using upstream base firmware as primary (${firmwareFile.name})")
                } catch (Throwable t) {
                    logger.warn("[archive] Failed copying upstream base to variant name: ${t.message}")
                }
            }
            if (!firmwareFile.exists()) {
                def patterns = [
                    /^QEMU_VARS.*\.img$/, /^QEMU_EFI.*\.img$/, /^RELEASEX64_OVMF_VARS.*\.fd$/, /^RELEASEX64_OVMF.*\.fd$/, /^bios.*\.bin$/
                ]
                def candidates = firmwareDir.exists() ? (firmwareDir.listFiles()?.findAll { f -> patterns.any { p -> f.name ==~ p } } ?: []) : []
                if (candidates.isEmpty()) {
                    throw new GradleException("[archive] Expected firmware file not found after extraction; upstream raw attempt also failed. Directory=${firmwareDir}")
                }
                def chosen = candidates.sort { -it.length() }[0]
                primarySource = 'fallbackBios'
                logger.warn("[archive] WARNING: Using BIOS/OVMF fallback ${chosen.name} (${chosen.length()} bytes) instead of missing ${firmwareFile.name}; variable store / persistence may differ.")
                try {
                    java.nio.file.Files.copy(chosen.toPath(), firmwareFile.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING)
                    logger.lifecycle("[archive] Fallback copied to ${firmwareFile.name}")
                } catch (Throwable t) {
                    throw new GradleException("[archive] Failed to create fallback primary firmware file: ${t.message}", t)
                }
            }
        }
        // Post acquisition hash verify (skip if fallback BIOS and hash provided for QEMU_VARS)
        if (expectedSha256 && firmwareFile.exists() && primarySource != 'fallbackBios') {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                firmwareFile.delete()
                throw new GradleException("[archive] Firmware SHA-256 mismatch after ${primarySource} acquisition. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("[archive] Firmware SHA-256 verified for primary (${primarySource}).")
        } else if (expectedSha256 && primarySource == 'fallbackBios') {
            logger.warn("[archive] Skipping provided hash verification because fallback BIOS file was used (hash intended for QEMU_VARS).")
        }
        // Enrich inventory with primarySource
        try {
            def invFile = new File(firmwareDir, 'firmware-inventory.json')
            if (invFile.exists()) {
                def parsed = new groovy.json.JsonSlurper().parseText(invFile.text)
                if (parsed instanceof Map) {
                    parsed.primarySource = primarySource
                    if (parsed.files instanceof List) {
                        def entry = parsed.files.find { it.name == firmwareFile.name }
                        if (!entry) {
                            parsed.files << [ name: firmwareFile.name, size: firmwareFile.length(), sha256: computeSha256(firmwareFile), source: primarySource ]
                        } else {
                            entry.size = firmwareFile.length()
                            entry.sha256 = computeSha256(firmwareFile)
                            entry.source = primarySource
                        }
                    }
                    invFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(parsed))
                    logger.lifecycle("[archive] Inventory updated with primarySource=${primarySource}")
                }
            }
        } catch (Throwable t) {
            logger.warn("[archive] Failed updating inventory with primarySource: ${t.message}")
        }
        return // short-circuit direct download logic
    }
    boolean needsDownload = !firmwareFile.exists()
    String cachedEtag = readMetaFile(metadataFile, 'etag')
        if (!needsDownload) {
            logger.lifecycle("Firmware present: ${firmwareFile.name} (${firmwareFile.length()} bytes)")
            // Optionally attempt conditional HEAD to verify if remote changed when hash provided
            // (skip if no hash + no variant change)
        }
        if (!firmwareDir.exists() && !firmwareDir.mkdirs()) {
            throw new GradleException("Could not create firmware directory: ${firmwareDir}")
        }
        if (!needsDownload) {
            logger.lifecycle("No download needed (file exists). Use -PforceFirmware or delete file to refetch.")
        }
        if (project.hasProperty('forceFirmware')) {
            logger.lifecycle('forceFirmware flag set: re-downloading regardless of existing file.')
            needsDownload = true
        }
        if (!needsDownload) {
            // Still perform integrity verification if expected hash provided
            if (expectedSha256) {
                def actualPre = computeSha256(firmwareFile)
                if (!actualPre?.equalsIgnoreCase(expectedSha256)) {
                    logger.lifecycle("Existing firmware hash mismatch; re-downloading.")
                    needsDownload = true
                }
            }
        }
        if (!needsDownload) return
        logger.lifecycle("Fetching firmware variant='${firmwareVariant}' from ${firmwareUrl} (maxAttempts=${maxAttempts})")
        int attempt = 1
        boolean success = false
        while (attempt <= maxAttempts && !success) {
            File tmp = new File(firmwareFile.parentFile, firmwareFile.name + '.part')
            if (tmp.exists()) tmp.delete()
            try {
                def url = new URL(firmwareUrl)
                url.openConnection().with { conn ->
                    conn.connectTimeout = 15000
                    conn.readTimeout = 600000 // 10 min
                    if (cachedEtag) {
                        conn.setRequestProperty('If-None-Match', cachedEtag)
                    }
                    int code = conn.getResponseCode()
                    if (code == 304) {
                        logger.lifecycle("[attempt ${attempt}] Remote reports Not Modified (ETag match); skipping download body.")
                        return
                    }
                    conn.inputStream.withCloseable { input ->
                        tmp.withOutputStream { out ->
                            byte[] buf = new byte[1 * 1024 * 1024]
                            long total = 0
                            long lastReport = System.currentTimeMillis()
                            int r
                            while ((r = input.read(buf)) != -1) {
                                out.write(buf, 0, r)
                                total += r
                                def now = System.currentTimeMillis()
                                if (now - lastReport > 5000) {
                                    logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Downloaded %,d bytes...", attempt, total))
                                    lastReport = now
                                }
                            }
                            logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Download complete (%,d bytes).", attempt, total))
                        }
                    }
                    def etag = conn.getHeaderField('ETag')
                    if (etag) {
                        writeMetaFile(metadataFile, [etag: etag])
                        logger.lifecycle("Captured ETag (primary asset): ${etag}")
                    }
                }
                // Atomic move
                if (firmwareFile.exists()) firmwareFile.delete()
                if (!tmp.renameTo(firmwareFile)) {
                    throw new GradleException("Could not rename temp file ${tmp} to ${firmwareFile}")
                }
                success = true
            } catch (Throwable t) {
                logger.warn("[attempt ${attempt}] Firmware download failed: ${t.class.simpleName}: ${t.message}")
                attempt++
                if (attempt <= maxAttempts) {
                    long backoff = (long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L) // 1s,2s,4s,8s...
                    logger.lifecycle("Retrying in ${backoff} ms ...")
                    sleep(backoff)
                }
            }
        }
        if (!success) {
            throw new GradleException("Failed to download firmware after ${maxAttempts} attempts: ${firmwareUrl}")
        }
        if (expectedSha256) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                firmwareFile.delete()
                throw new GradleException("Firmware SHA-256 mismatch. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware SHA-256 verified: ${actual}")
        } else {
            logger.lifecycle("No expected SHA-256 provided; skipping integrity verification.")
        }
    }
}

// --- Optional GPG signature verification (detached .sig) -----------------------------
// Provide -PfirmwareSigUrl or env QEMU_VARS_SIG_URL for primary asset. Requires gpg in PATH.
def firmwareSigUrl = (project.findProperty('firmwareSigUrl') ?: System.getenv('QEMU_VARS_SIG_URL'))
def firmwareSigFile = file("${firmwareFile}.sig")

tasks.register('fetchFirmwareSignature') {
    description = 'Fetches detached GPG signature for primary firmware if firmwareSigUrl provided.'
    group = 'vectras'
    onlyIf { firmwareSigUrl && !skipFirmware }
    doLast {
        logger.lifecycle("Downloading signature from ${firmwareSigUrl}")
        def url = new URL(firmwareSigUrl)
        url.openConnection().with { c ->
            c.connectTimeout = 10000
            c.readTimeout = 60000
            c.inputStream.withCloseable { input ->
                firmwareSigFile.withOutputStream { out -> out << input }
            }
        }
        logger.lifecycle("Signature saved: ${firmwareSigFile} (${firmwareSigFile.length()} bytes)")
    }
}

tasks.register('verifyFirmwareSignature') {
    description = 'Verifies firmware GPG signature (requires gpg and fetched signature).'
    group = 'verification'
    dependsOn 'fetchFirmware', 'fetchFirmwareSignature'
    onlyIf { firmwareSigUrl && !skipFirmware }
    doLast {
        if (!firmwareSigFile.exists()) throw new GradleException("Signature file missing: ${firmwareSigFile}")
        logger.lifecycle("Verifying signature via gpg --verify ...")
        def proc = [ 'gpg', '--verify', firmwareSigFile.absolutePath, firmwareFile.absolutePath ].execute()
        def out = new StringBuffer(); def err = new StringBuffer();
        proc.consumeProcessOutput(out, err)
        proc.waitFor()
        logger.lifecycle(out.toString())
        if (proc.exitValue() != 0) {
            logger.error(err.toString())
            throw new GradleException("Firmware signature verification failed (exit=${proc.exitValue()})")
        }
        logger.lifecycle("Firmware signature verified successfully.")
    }
}

tasks.register('ciAllFirmwareSecureCheck') {
    description = 'CI: fetch all assets + verify primary hash + signature if provided + print hash.'
    group = 'verification'
    dependsOn 'fetchAllFirmware', 'verifyFirmware', 'printFirmwareSha256', 'verifyFirmwareSignature'
}
tasks.register('verifyFirmware') {
    description = 'Verifies existing firmware file matches expected SHA-256 (if provided).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (skipFirmware) {
            logger.lifecycle('Firmware fetch skipped; verifyFirmware doing nothing.')
            return
        }
        if (!firmwareFile.exists()) {
            throw new GradleException("Firmware file not found: ${firmwareFile}")
        }
        if (expectedSha256 && !skipFirmwareVerify) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                throw new GradleException("Firmware verification failed. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware verification succeeded (SHA-256=${actual}).")
        } else {
            logger.lifecycle("No firmware SHA-256 provided or verification skipped.")
        }
    }
}

// Print computed SHA-256 (after fetch or existing) for convenience
tasks.register('printFirmwareSha256') {
    description = 'Prints SHA-256 of firmware file (fetches first if needed unless skipped).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (!firmwareFile.exists()) {
            logger.lifecycle("Firmware not present; nothing to hash.")
            return
        }
        def actual = computeSha256(firmwareFile)
        logger.lifecycle("Firmware file: ${firmwareFile.name}")
        logger.lifecycle("Variant: ${firmwareVariant}")
        logger.lifecycle("SHA-256: ${actual}")
        println(actual)
    }
}

// Multi-asset parallel fetch (best-effort). Each asset can override URL & hash via properties:
// -Passet.<base>.url / env <BASE>_URL   and -Passet.<base>.sha256 / env <BASE>_SHA256
// Example: -Passet.RELEASEX64_OVMF_VARS.url=https://.../RELEASEX64_OVMF_VARS-default.fd
tasks.register('fetchAllFirmware') {
    group = 'vectras'
    description = 'Fetches all defined firmware assets (primary + secondary).'    
    onlyIf { !skipFirmware }
    doLast {
        if (!firmwareDir.exists()) firmwareDir.mkdirs()
        firmwareAssets.parallelStream().forEach { a ->
            File target = file("${firmwareDir}/${a.base}-${firmwareVariant}.${a.ext}")
            File meta = file("${firmwareDir}/${a.base}-${firmwareVariant}.meta")
            String urlOverride = (project.findProperty("asset.${a.base}.url") ?: System.getenv(a.envUrl) ?: "https://example.com/path/to/${a.base}-${firmwareVariant}.${a.ext}")
            String shaOverride = (project.findProperty("asset.${a.base}.sha256") ?: System.getenv(a.envSha))
            boolean force = project.hasProperty('forceFirmware')
            boolean need = force || !target.exists()
            if (!need && shaOverride) {
                def existing = computeSha256(target)
                if (!existing?.equalsIgnoreCase(shaOverride)) {
                    need = true
                }
            }
            if (!need) {
                logger.lifecycle("[multi] ${target.name} already present")
                return
            }
            logger.lifecycle("[multi] Downloading ${a.base} variant=${firmwareVariant} from ${urlOverride}")
            File tmp = new File(target.parentFile, target.name + '.part')
            if (tmp.exists()) tmp.delete()
            int attempt = 1
            int max = maxAttempts
            boolean ok = false
            while (attempt <= max && !ok) {
                try {
                    def u = new URL(urlOverride)
                    u.openConnection().with { conn ->
                        conn.connectTimeout = 15000
                        conn.readTimeout = 600000
                        conn.inputStream.withCloseable { input ->
                            tmp.withOutputStream { out ->
                                byte[] buf = new byte[1*1024*1024]
                                int r
                                long total = 0
                                long lastReport = System.currentTimeMillis()
                                while ((r = input.read(buf)) != -1) {
                                    out.write(buf,0,r)
                                    total += r
                                    if (System.currentTimeMillis() - lastReport > 5000) {
                                        logger.lifecycle(String.format(Locale.ROOT, "[multi %s attempt %d] %,d bytes", a.base, attempt, total))
                                        lastReport = System.currentTimeMillis()
                                    }
                                }
                                logger.lifecycle(String.format(Locale.ROOT, "[multi %s attempt %d] complete (%,d bytes)", a.base, attempt, total))
                            }
                        }
                        def et = conn.getHeaderField('ETag')
                        if (et) writeMetaFile(meta, [etag: et])
                    }
                    if (target.exists()) target.delete()
                    if (!tmp.renameTo(target)) throw new GradleException("Could not finalize ${target}")
                    if (shaOverride) {
                        def got = computeSha256(target)
                        if (!got?.equalsIgnoreCase(shaOverride)) {
                            target.delete(); throw new GradleException("SHA mismatch for ${a.base} expected=${shaOverride} got=${got}")
                        }
                    }
                    ok = true
                } catch (Throwable t) {
                    logger.warn("[multi ${a.base}] attempt ${attempt} failed: ${t.class.simpleName}: ${t.message}")
                    attempt++
                    if (attempt <= max) {
                        long back = (long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L)
                        sleep(back)
                    }
                }
            }
            if (!ok) throw new GradleException("Failed to fetch asset ${a.base} after ${max} attempts")
            if (!shaOverride) logger.lifecycle("[multi] ${a.base} done (no hash to verify)")
        }
    }
}

// Aggregate multi asset + standard verify (primary) for CI convenience
tasks.register('ciAllFirmwareCheck') {
    group = 'verification'
    description = 'Fetch all assets + verify primary asset hash + print primary hash.'
    dependsOn 'fetchAllFirmware', 'verifyFirmware', 'printFirmwareSha256'
}

// Aggregate CI convenience task: fetch + verify (if hash) + print hash
tasks.register('ciFirmwareCheck') {
    description = 'CI helper: ensures firmware present, verifies (if hash), and prints hash.'
    group = 'verification'
    dependsOn tasks.named('verifyFirmware'), tasks.named('printFirmwareSha256')
}

// Lightweight guard assertion (non-fatal) to help ensure sample SHA not shipped accidentally.
tasks.register('assertNoSampleFirmwareSha') {
    group = 'verification'
    description = 'Fails if the sample placeholder firmware SHA is still configured (unless allow flag present).'
    doLast {
        if (expectedSha256 && expectedSha256.equalsIgnoreCase(sampleShaPlaceholder) && !project.hasProperty('allowSampleFirmwareSha')) {
            throw new GradleException("Sample placeholder firmware SHA in use. Replace with production value or run with -PallowSampleFirmwareSha if intentional.")
        } else if (expectedSha256?.equalsIgnoreCase(sampleShaPlaceholder)) {
            logger.lifecycle("Sample SHA allowed explicitly via -PallowSampleFirmwareSha.")
        } else {
            logger.lifecycle("No sample firmware SHA detected.")
        }
    }
}

// Composite quality gate bundling all relevant firmware checks.
tasks.register('firmwareQualityGate') {
    group = 'verification'
    description = 'Fetch all firmware, verify primary hash, optional signature, print hash, and assert sample SHA not used.'
    dependsOn 'ciAllFirmwareSecureCheck', 'assertNoSampleFirmwareSha'
}

// Simple assertion task for CI: ensure archive extraction actually produced at least one firmware file.
tasks.register('firmwareArchivePresenceTest') {
    group = 'verification'
    description = 'Fails if archive flow enabled and no expected firmware files were extracted.'
    onlyIf { archiveEnabled }
    dependsOn 'extractFirmwareFromArchive'
    doLast {
        def expectedPatterns = [
            /^QEMU_VARS.*\.img$/, /^QEMU_EFI.*\.img$/, /^RELEASEX64_OVMF.*\.fd$/, /^bios.*\.bin$/
        ]
        if (!firmwareDir.exists()) throw new GradleException('[archive-test] Firmware directory missing.')
        def matches = firmwareDir.listFiles()?.findAll { f -> expectedPatterns.any { p -> f.name ==~ p } } ?: []
        if (matches.isEmpty()) {
            throw new GradleException('[archive-test] No firmware files found after extraction; check archive or patterns.')
        }
        logger.lifecycle("[archive-test] Found firmware files: ${matches.collect{it.name}.join(', ')}")
    }
}
// Ensure firmware is present before building APK (unless skipped)
tasks.matching { it.name == 'preBuild' }.configureEach {
    if (!skipFirmware) {
        dependsOn tasks.named('fetchFirmware')
    } else {
        logger.lifecycle('Skipping firmware fetch due to -PskipFirmware flag.')
    }
}

// Minimal environment validation task (no firmware download) for CI quick-check
tasks.register('envCheck') {
    group = 'verification'
    description = 'Validates essential environment: SDK path, Java version, gradle plugin versions; skips firmware.'
    doLast {
        // Basic SDK detection replicating scripts/check-env logic
        def sdkDir = null
        def localProps = file('../local.properties')
        if (localProps.exists()) {
            def line = localProps.readLines().find { it.startsWith('sdk.dir=') }
            if (line) sdkDir = line.substring('sdk.dir='.length())
        }
        if (!sdkDir) sdkDir = System.getenv('ANDROID_HOME')
        if (!sdkDir) sdkDir = System.getenv('ANDROID_SDK_ROOT')
        if (!sdkDir) {
            throw new GradleException('envCheck: Android SDK path not found (local.properties sdk.dir or ANDROID_HOME / ANDROID_SDK_ROOT required).')
        }
        if (!file(sdkDir).exists()) {
            throw new GradleException("envCheck: Android SDK directory does not exist: ${sdkDir}")
        }
        logger.lifecycle("envCheck: SDK directory = ${sdkDir}")

        // Java version (should be 17+ for current toolchain)
        def javaVersion = org.gradle.internal.jvm.Jvm.current().javaVersion
        if (javaVersion < JavaVersion.VERSION_17) {
            throw new GradleException("envCheck: Java 17+ required. Detected: ${javaVersion}")
        }
        logger.lifecycle("envCheck: Java version = ${javaVersion}")

        // Assert critical plugins are on expected versions (best-effort)
        def agp = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION
        logger.lifecycle("envCheck: Android Gradle Plugin version = ${agp}")

        // If signature verification is requested, ensure gpg is available
        def sigRequested = (project.findProperty('firmwareSigUrl') ?: System.getenv('QEMU_VARS_SIG_URL'))
        if (sigRequested) {
            def gpgOk = ['gpg','--version'].execute()
            gpgOk.waitForOrKill(5000)
            if (gpgOk.exitValue() != 0) {
                throw new GradleException('envCheck: gpg not found on PATH but firmware signature URL provided.')
            }
            logger.lifecycle('envCheck: gpg available for signature verification.')
        }
    }
}

// Apply Crashlytics plugin if the classpath provides it
try {
    apply plugin: 'com.google.firebase.crashlytics'
} catch (Exception ignored) {
    logger.warn('Firebase Crashlytics Gradle plugin not available on classpath; skipping crashlytics setup.')
}

// Apply Google Services plugin only if google-services.json exists.
if (file("google-services.json").exists()) {
    apply plugin: 'com.google.gms.google-services'
} else {
    logger.warn('google-services.json not found in app/ — skipping com.google.gms.google-services plugin. Add the file from Firebase Console to enable Analytics and other Firebase services.')
}
