plugins {
    id 'com.android.application'
}

android {
    namespace = 'com.vectras.vm'
    compileSdk = rootProject.ext.compileApi

    defaultConfig {
        applicationId = "com.vectras.vm"
        minSdk = rootProject.ext.minApi
        targetSdk = rootProject.ext.targetApi
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled = false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    buildFeatures {
        viewBinding true
        dataBinding true
    }
    lint {
        // Create a baseline for the existing lint warnings/errors so the build is not blocked.
        // Run `./gradlew updateLintBaseline` once to generate `lint-baseline.xml` and commit it.
        // This preserves current issues while allowing incremental fixes over time.
        baseline = file("lint-baseline.xml")
        abortOnError false
    }
}

dependencies {
    // Glide
    implementation 'com.github.bumptech.glide:glide:4.16.0'
    annotationProcessor 'com.github.bumptech.glide:compiler:4.16.0'

    // Test dependencies
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    // Common AndroidX / Material dependencies (provide styles, widgets and themes required by the layouts)
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.core:core-ktx:1.10.1'
    implementation 'com.google.android.material:material:1.9.0'
    implementation 'androidx.preference:preference:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    implementation 'com.airbnb.android:lottie:5.2.0'
    implementation project(':terminal-view')
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
    implementation 'com.google.guava:guava:32.1.2-android'
    implementation 'org.zeroturnaround:zt-zip:1.14'
    implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
    implementation 'androidx.activity:activity-ktx:1.8.0'
    implementation 'androidx.recyclerview:recyclerview:1.3.0'
}

// --- Firmware / ROM asset fetch (non-LFS on fork) ------------------------------------------
// Provides a lightweight way to obtain large firmware files (e.g., QEMU_VARS.img)
// without committing them to this fork. Precedence for URL selection:
//   -PfirmwareUrl Gradle property > QEMU_VARS_URL env var > placeholder default.
// Optional integrity check:
//   -PfirmwareSha256 or QEMU_VARS_SHA256 env var (expected lowercase hex). If provided, the
// downloaded file's SHA-256 must match or the build fails.
// Retry behavior controlled by -PfirmwareAttempts (default 3) or env QEMU_VARS_ATTEMPTS.
// Skip fetch: -PskipFirmware ; Skip verification: -PskipFirmwareVerify
// NOTE: If both skipFirmware and verify requested, verify is effectively skipped (no file).

def firmwareDir = file("${project.projectDir}/src/main/assets/roms")
// Firmware variant (e.g., default, debug, secure). Allows multiple images hosted externally.
def firmwareVariant = (project.findProperty('firmwareVariant') ?: System.getenv('QEMU_VARS_VARIANT') ?: 'default')
def firmwareBaseName = 'QEMU_VARS'
def firmwareFile = file("${firmwareDir}/${firmwareBaseName}-${firmwareVariant}.img")

def firmwareUrl = (project.findProperty('firmwareUrl') ?: System.getenv('QEMU_VARS_URL') ?: "https://example.com/path/to/${firmwareBaseName}-${firmwareVariant}.img")
def expectedSha256 = (project.findProperty('firmwareSha256') ?: System.getenv('QEMU_VARS_SHA256'))
def maxAttempts = (project.findProperty('firmwareAttempts') ?: System.getenv('QEMU_VARS_ATTEMPTS') ?: '3') as int
def skipFirmware = project.hasProperty('skipFirmware')
def skipFirmwareVerify = project.hasProperty('skipFirmwareVerify')

def computeSha256 = { File f ->
    if (!f.exists()) return null
    def md = java.security.MessageDigest.getInstance('SHA-256')
    f.withInputStream { is ->
        byte[] buf = new byte[8192]
        int r
        while ((r = is.read(buf)) != -1) {
            md.update(buf, 0, r)
        }
    }
    return md.digest().collect { String.format('%02x', it) }.join('')
}

// Cache metadata (e.g., ETag) to allow conditional HTTP requests.
def metadataFile = file("${firmwareDir}/${firmwareBaseName}-${firmwareVariant}.meta")
def readMeta = { String key ->
    if (!metadataFile.exists()) return null
    def props = new Properties()
    metadataFile.withInputStream { props.load(it) }
    return props.getProperty(key)
}
def writeMeta = { Map<String,String> map ->
    def props = new Properties()
    if (metadataFile.exists()) {
        metadataFile.withInputStream { props.load(it) }
    } else {
        if (!firmwareDir.exists()) firmwareDir.mkdirs()
    }
    map.each { k,v -> if (v!=null) props.setProperty(k,v) }
    metadataFile.withOutputStream { out -> props.store(out, 'Firmware metadata cache') }
}

tasks.register('fetchFirmware') {
    description = 'Downloads firmware image if missing or outdated (retries, SHA-256 verify, ETag cache).'
    group = 'vectras'
    outputs.file(firmwareFile)
    onlyIf { !skipFirmware }
    doLast {
        boolean needsDownload = !firmwareFile.exists()
        String cachedEtag = readMeta('etag')
        if (!needsDownload) {
            logger.lifecycle("Firmware present: ${firmwareFile.name} (${firmwareFile.length()} bytes)")
            // Optionally attempt conditional HEAD to verify if remote changed when hash provided
            // (skip if no hash + no variant change)
        }
        if (!firmwareDir.exists() && !firmwareDir.mkdirs()) {
            throw new GradleException("Could not create firmware directory: ${firmwareDir}")
        }
        if (!needsDownload) {
            logger.lifecycle("No download needed (file exists). Use -PforceFirmware or delete file to refetch.")
        }
        if (project.hasProperty('forceFirmware')) {
            logger.lifecycle('forceFirmware flag set: re-downloading regardless of existing file.')
            needsDownload = true
        }
        if (!needsDownload) {
            // Still perform integrity verification if expected hash provided
            if (expectedSha256) {
                def actualPre = computeSha256(firmwareFile)
                if (!actualPre?.equalsIgnoreCase(expectedSha256)) {
                    logger.lifecycle("Existing firmware hash mismatch; re-downloading.")
                    needsDownload = true
                }
            }
        }
        if (!needsDownload) return
        logger.lifecycle("Fetching firmware variant='${firmwareVariant}' from ${firmwareUrl} (maxAttempts=${maxAttempts})")
        int attempt = 1
        boolean success = false
        while (attempt <= maxAttempts && !success) {
            File tmp = new File(firmwareFile.parentFile, firmwareFile.name + '.part')
            if (tmp.exists()) tmp.delete()
            try {
                def url = new URL(firmwareUrl)
                url.openConnection().with { conn ->
                    conn.connectTimeout = 15000
                    conn.readTimeout = 600000 // 10 min
                    if (cachedEtag) {
                        conn.setRequestProperty('If-None-Match', cachedEtag)
                    }
                    conn.inputStream.withCloseable { input ->
                        tmp.withOutputStream { out ->
                            byte[] buf = new byte[1 * 1024 * 1024]
                            long total = 0
                            long lastReport = System.currentTimeMillis()
                            int r
                            while ((r = input.read(buf)) != -1) {
                                out.write(buf, 0, r)
                                total += r
                                def now = System.currentTimeMillis()
                                if (now - lastReport > 5000) {
                                    logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Downloaded %,d bytes...", attempt, total))
                                    lastReport = now
                                }
                            }
                            logger.lifecycle(String.format(Locale.ROOT, "[attempt %d] Download complete (%,d bytes).", attempt, total))
                        }
                    }
                    def etag = conn.getHeaderField('ETag')
                    if (etag) {
                        writeMeta(etag: etag)
                        logger.lifecycle("Captured ETag: ${etag}")
                    }
                }
                // Atomic move
                if (firmwareFile.exists()) firmwareFile.delete()
                if (!tmp.renameTo(firmwareFile)) {
                    throw new GradleException("Could not rename temp file ${tmp} to ${firmwareFile}")
                }
                success = true
            } catch (Throwable t) {
                logger.warn("[attempt ${attempt}] Firmware download failed: ${t.class.simpleName}: ${t.message}")
                attempt++
                if (attempt <= maxAttempts) {
                    long backoff = (long)Math.min(30000, Math.pow(2, attempt - 2) * 1000L) // 1s,2s,4s,8s...
                    logger.lifecycle("Retrying in ${backoff} ms ...")
                    sleep(backoff)
                }
            }
        }
        if (!success) {
            throw new GradleException("Failed to download firmware after ${maxAttempts} attempts: ${firmwareUrl}")
        }
        if (expectedSha256) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                firmwareFile.delete()
                throw new GradleException("Firmware SHA-256 mismatch. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware SHA-256 verified: ${actual}")
        } else {
            logger.lifecycle("No expected SHA-256 provided; skipping integrity verification.")
        }
    }
}

tasks.register('verifyFirmware') {
    description = 'Verifies existing firmware file matches expected SHA-256 (if provided).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (skipFirmware) {
            logger.lifecycle('Firmware fetch skipped; verifyFirmware doing nothing.')
            return
        }
        if (!firmwareFile.exists()) {
            throw new GradleException("Firmware file not found: ${firmwareFile}")
        }
        if (expectedSha256 && !skipFirmwareVerify) {
            def actual = computeSha256(firmwareFile)
            if (!actual?.equalsIgnoreCase(expectedSha256)) {
                throw new GradleException("Firmware verification failed. Expected=${expectedSha256} Actual=${actual}")
            }
            logger.lifecycle("Firmware verification succeeded (SHA-256=${actual}).")
        } else {
            logger.lifecycle("No firmware SHA-256 provided or verification skipped.")
        }
    }
}

// Print computed SHA-256 (after fetch or existing) for convenience
tasks.register('printFirmwareSha256') {
    description = 'Prints SHA-256 of firmware file (fetches first if needed unless skipped).'
    group = 'vectras'
    dependsOn tasks.named('fetchFirmware')
    doLast {
        if (!firmwareFile.exists()) {
            logger.lifecycle("Firmware not present; nothing to hash.")
            return
        }
        def actual = computeSha256(firmwareFile)
        logger.lifecycle("Firmware file: ${firmwareFile.name}")
        logger.lifecycle("Variant: ${firmwareVariant}")
        logger.lifecycle("SHA-256: ${actual}")
        println(actual)
    }
}

// Aggregate CI convenience task: fetch + verify (if hash) + print hash
tasks.register('ciFirmwareCheck') {
    description = 'CI helper: ensures firmware present, verifies (if hash), and prints hash.'
    group = 'verification'
    dependsOn tasks.named('verifyFirmware'), tasks.named('printFirmwareSha256')
}

// Ensure firmware is present before building APK (unless skipped)
tasks.matching { it.name == 'preBuild' }.configureEach {
    if (!skipFirmware) {
        dependsOn tasks.named('fetchFirmware')
    } else {
        logger.lifecycle('Skipping firmware fetch due to -PskipFirmware flag.')
    }
}

// Apply Crashlytics plugin if the classpath provides it
try {
    apply plugin: 'com.google.firebase.crashlytics'
} catch (Exception ignored) {
    logger.warn('Firebase Crashlytics Gradle plugin not available on classpath; skipping crashlytics setup.')
}

// Apply Google Services plugin only if google-services.json exists.
if (file("google-services.json").exists()) {
    apply plugin: 'com.google.gms.google-services'
} else {
    logger.warn('google-services.json not found in app/ — skipping com.google.gms.google-services plugin. Add the file from Firebase Console to enable Analytics and other Firebase services.')
}
